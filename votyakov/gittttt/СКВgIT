#командную строку баш переносим в то место, где должен быть репощиторий

git init #инициализация гита 
cd ls 
git status #увидеть данные о репозитории 
git add 'name' #добавить файл в трек
git *.txt #добавить все текстовые файлы в трек (с расширением .txt)
git commit -m "Text" #отправить правку с пояснением 
git config --global user.email "oneglyde@gmail.com"
git config --global user.name "oneglyde"
git log #лог коммитов 
git checkout b0c1f61945233b3b03379c90e82d8b08154ef5f2 (адрес коммита, достаточно первых 4-х символов) #откат программы к предыдущему коммиту (перенести хед на предыдущий коммит)
git checkout main #перенести хед на мейн-ветку (main - название ветки)
git checkout -b [yourbranchname] #cоздать и переключиться на ветку при помощи одной команды 
git branch -a #посмотреть на все существующие ветки
git branch new_branch / git checkout -b new_brunch #создать новую ветку (new_branch - название новой ветки)
git merge main #слияние (должен быть выполнен чекаут другой ветки помимо main (new_branch))
git rebase new_branch #ребазируем main туда, где находится new branch (перемещаем маркер) (должен быть выполнен чекаут мастер)
git branch -D new_branch #удалить ненужную ветку
git switch name_of_branch #тоже работает как чекаут

git checkout name_of_hash^ #Перемещение на один коммит назад (первый родитель ветки name_of_hash) name_of_hash^^ - прародитель (переносится хед). Можно также использовать HEAD как относительную ссылку (HEAD^^). 

git checkout name_of_brunc~<num> #Перемещение на несколько коммитов назад. Укажем после ~ число коммитов, через которые надо пройти.

git branch -f name_of_brunch name_of_commit - переместить ветку name_of_brunch на name_of_commit

git branch -f main HEAD~3 - переместит мейн на три родителя назад от хед

git reset (локально) #отменяет изменения, перенося ссылку на ветку назад, на более старый коммит. Это своего рода "переписывание истории";        git reset перенесёт ветку назад, как будто некоторых коммитов вовсе и не было.
указываем после ресет куда свдинуть ветку, а все что ниже удалится (да?)

git revert (удаленно) #Reset отлично работает на локальных ветках, в локальных репозиториях. Но этот метод переписывания истории не сработает на удалённых ветках, которые используют другие пользователи.Чтобы отменить изменения и поделиться отменёнными изменениями с остальными, надо использовать git revert. Посмотрим, как это работает
Забавно, появился новый коммит. Дело в том, что новый коммит C2' просто содержит изменения, полностью противоположные тем, что сделаны в коммите C2.

После revert можно сделать push и поделиться изменениями с остальными.


#разрабатывая что-то на дополнительной ветке, перенести это в мейн можно выбрыв чекаутом коммит (навести хед) и затем ребазировать 
этот коммит в мейн, таким образом нужные коммиты окажутся в мастер ветке (в дополнительной тоже останутся)

#игнорирование: 
создаем текстовый файл с названием '.gitignore' и перечисляем в нем названия всех файлов, которые следует игнорировать 

#нетрекающиеся файлы не удаляются при откате программы и вообще не подвержены гит-изменениям 

#конфликты происходят если в разных коммитах например один и тот же файл выглядит по разному, запускается инструментальная ветка которая предполагает устранение конфликта в конфликтных файлах 


git branch -M new_name # переименовать бранч

#github инструкция переноса офлайн репозитория 

***
git remote add origin https://github.com/oneglyde/gittest.git
git branch -M main
git push -u origin main
***

git clone <repository adress> # клонировать проект из репозитория на компьютер
git push # отправить изменения 

